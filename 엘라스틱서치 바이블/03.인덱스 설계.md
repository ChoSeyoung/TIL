## 인덱스 설정
```
GET [인덱스 이름]/_settings
```
### number_of_shards
인덱스가 데이터를 몇개의 샤드로 처리할것인지 지정하는 값.
한번 지정하면 reindex 같은 동작을 통해 인덱스를 통째로 재색인하는 등 특별한 작업을 수행하지 않는 한 변경할 수 없다.
샤드 하나마다 루씬 인덱스가 하나씩 더 생성된다는 사실과 주 샤드 하나당 복제본 샤드도 늘어난다.
클러스터에 샤드 숫자가 너무 많아지면 클러스터 성능이 떨어지고, 특히 색인 성능이 감소한다.
클러스터에 샤드 숫자가 너무 적어지면 장애 상황에서 샤드 복구 상황에 너무 많은 시간이 소요되고 클러스터 안정성이 떨어진다.

### number_of_replicas
주 샤드 하나당 복제본 샤드를 몇 개 둘 것인지 지정하는 값.
샤드와는 다르게 동적으로 변경 가능하다.
```
PUT [인덱스 이름]/_settings
{
  "index.number_of_replicas": 0
}
```
값을 0 으로 지정하면 복제본 샤드를 생성하지 않고 주 샤드만 둔다. 
값을 0 으로 주는 설정은 주로 대용량의 초기 데이터를 마이그레이션하는 등의 시나리오에서 쓰기 성능을 일시적으로 끌어올리기 위해 사용한다.

### refresh_interval
엘라스틱서치가 해당 인덱스를 대상으로 refresh를 얼마나 자주 수행할것인지를 지정하는 값.
엘라스틱서치 인덱스에 색인된 문서는 refresh 되어야 검색 대상이 되기 때문에 중요한 설정임.
```
PUT [인덱스 이름]/_setttings
{
  "index.refresh_interval": "1s"
}
```
값을 "1s"로 지정하면 1초에 한번씩 refresh를 수행한다. 
값을 -1로 지정하면 주기적으로 refresh를 수행하지 않는다.
해당 값이 명시적으로 설정되어있지 않다면 1초마다 refresh 를 수행한다.

## 매핑과 필드타입
매핑은 문서가 인덱스에 어떻게 색인되고 저장되는지 정의하는 부분이다. 

인덱스에 문서가 색인될 때 기존에 매핑 정보를 가지고 있지 않던 새로운 필드가 들어오면 
엘라스틱서치는 자동으로 문서의 내용을 보고 적당한 필드 타입을 지정해서 매핑 정보를 생성한다.

중요한 것은 필드 타입을 포함한 매핑 설정 내 대부분의 내용은 한 번 지정되면 사실상 변경이 불가능하다는 점이다. 
따라서 서비스 운영 환경에서 대용량의 데이터를 처리해야 할 때는 기본적으로 명시적 으로 매핑을 지정해서 인덱스를 운영해야 한다.

### 명시적 매핑 처리
```
PUT [인덱스 이름] 
{ 
  "mappings": { 
    "properties": { 
      "createdDate": { "type": "date", "format": "strict_date_time || epoch_millis" }, 
      "keywordString": { "type": "keyword" }, 
      "textString": { "type": "text" }
    } 
  }
}
```

### 매핑 추가
```
PUT [인덱스 이름]/_mapping 
{ 
  "properties": { "longValue": { "type": "long" } } 
}
```

## 필드 타입
|분류|종류|비고|
|---|---|---|
|심플 타입| text, keyword, date, long, double, boolean, ip 등|text, keyword, date에 대해 자세하게 짚고넘어가야한다.|
|계층 구조를 지원하는 타입| object, nested 등|-|
|그 외 특수한 타입| geo_point, geo_shape 등|-|

### 심플타입
|종류|설명|비고|
|---|---|---|
|long|64비트 부호 있는 정수||
|integer|32비트 부호 있는 정수||
|short|16비트 부호 있는 정수||
|byte|8비트 부호 있는 정수||
|double|64비트 부동소수점||
|float|32비트 부동소수점||
|epoch_millis|ms단위 epoch 시간|
|epoch_second|s단위 epoch 시간

### object와 nested차이
Elasticsearch에서 "object"와 "nested" 타입은 JSON 구조를 색인하는 방법에 있어서 중요한 차이점을 가집니다.

1. **Object 타입**: 기본적으로, Elasticsearch는 JSON 객체를 'object' 데이터 타입으로 취급합니다. 이 타입에서는, 중첩된 필드들이 독립적인 레코드로 취급되지 않고 상위 문서의 일부로 색인됩니다. 이는 객체 내의 개별 필드들이 서로 연관되어 있지 않다는 것을 의미합니다. 예를 들어, 한 문서 안에 여러 주소가 있는 경우, 각 주소의 필드들 (예: 도시, 거리명)은 서로 독립적으로 색인되며, 복잡한 관계를 표현하는 데 한계가 있습니다.

2. **Nested 타입**: 'nested' 데이터 타입은 중첩된 JSON 객체를 별도의 독립된 문서로 취급하여 색인합니다. 이를 통해 복잡한 데이터 구조에서 각 중첩된 객체 내의 필드들 간의 관계를 유지할 수 있습니다. 예를 들어, 한 사람이 여러 주소를 가지고 있고, 각 주소 내의 필드들 (예: 도시, 거리명)이 서로 연관되어 있다면, 'nested' 타입을 사용하는 것이 적합합니다. 이를 통해 더 정교한 쿼리가 가능해지고, 객체 간의 복잡한 관계를 효과적으로 표현할 수 있습니다.

간단히 말해서, 'object' 타입은 중첩된 데이터 구조를 단순한 방식으로 취급하는 반면, 'nested' 타입은 이러한 구조를 더 정교하게 처리하여 중첩된 객체 간의 관계를 유지합니다. 이 두 타입의 선택은 데이터의 구조와 쿼리의 필요성에 따라 결정되어야 합니다.


